use dummy as knowledge.
use green as module.
use azc as module.

module tygronEvents {
	
	%INDICATOR PERCEPT
	%Indicator should not be able to be added or deleted during a session. But their current value can change
	%during session.
		
	%Every cycle deletes old values of the indicator and inserts the new one if there are any updates.
	forall percept(indicators(List)), bel(indicator(IndicatorID,OldCurrent,OldTarget,OldZoneIndicatorsList), 
		member(indicator(IndicatorID,NewCurrent,NewTarget,NewZoneIndicatorsList),List)) 
		do delete(indicator(IndicatorID,OldCurrent,OldTarget,OldZoneIndicatorsList)) 
		+ insert(indicator(IndicatorID,NewCurrent,NewTarget,NewZoneIndicatorsList)).
	
	%ACTIONLOG PERCEPT
	%Get information about the change in indicators of performed actions.
	
	%Delete the old one for each stakeholder
	forall percept(action_logs(ActList)), bel(member(actionlog(StakeholderID,_,_,_),ActList), actionlog(StakeholderID,OldDescription,OldActionID,OldIncList))
		do delete(actionlog(StakeholderID,OldDescription,OldActionID,OldIncList)).
	
	%Add the new one for each stakeholde.
	forall percept(action_logs(ActList)), bel(member(actionlog(StakeholderID,Description,ActionID,IncList),ActList))
		do insert(actionlog(StakeholderID,Description,ActionID,IncList)).
	
	%ZONE PERCEPT
	%Zones should not be able to be added or deleted during a session. But they should be able to be changed.
	
	%Every cycle deletes old values of the zones and inserts the new one if there are any updates.
	forall percept(zones(List)), bel(zone(ZoneID,OldName,OldFloors,OldSize,OldCategoriesList), 
		member(zone(ZoneID,NewName,NewFloors,NewSize,NewCategoriesList),List)) 
		do delete(zone(ZoneID,OldName,OldFloors,OldSize,OldCategoriesList)) 
		+ insert(zone(ZoneID,NewName,NewFloors,NewSize,NewCategoriesList)).
	
	%BUILDING PERCEPT
	%Buildings can be removed (destroyed), added (simply built) and changed (upgrades).
	
	%If new buildings appear in the list, add them to our belief base.
	forall percept(buildings(List)), bel(member(building(BuildingID,Name,OwnerID,ConstructionYear,CategoriesList,FuncID,Floors,MultiPolygon),List), 
		not(building(BuildingID,_,_,_,_,_,_,_))) do insert(building(BuildingID,Name,OwnerID,ConstructionYear,CategoriesList,FuncID,Floors,MultiPolygon)).
		
	%Every cycle deletes old values of the buildings and insert the new one if there are any updates
	forall percept(buildings(List)), bel(building(BuildingID,OldName,OldOwnerID,OldConstructionYear,OldCategoriesList,OldFuncID,OldFloors,OldMultiPolygon), 
		member(building(BuildingID, NewName,NewOwnerID,NewConstructionYear,NewCategoriesList,NewFuncID,NewFloors,NewMultiPolygon),List)) 
		do delete(building(BuildingID,OldName,OldOwnerID,OldConstructionYear,OldCategoriesList,OldFuncID,OldFloors,OldMultiPolygon)) + 
		insert(building(BuildingID, NewName,NewOwnerID,NewConstructionYear,NewCategoriesList,NewFuncID,NewFloors,NewMultiPolygon)).
		
	%Every cycle checks if a building is no longer there. If so, it deletes the building belief from the belief base
	forall percept(buildings(List)), bel(building(BuildingID,OldName,OldOwnerID,OldConstructionYear,OldCategoriesList,OldFuncID,OldFloors,OldMultiPolygon),
		not(member(building(BuildingID,_,_,_,_,_,_,_),List))) do 
		delete(building(BuildingID,OldName,OldOwnerID,OldConstructionYear,OldCategoriesList,OldFuncID,OldFloors,OldMultiPolygon)).
	
	%LAND PERCEPT
	%Lands can be added (one stakeholder could only buy one part of a patch of land of another stakeholder,
	%creating 2 new patches which should have different ID's). Lands can be changed (change of owner for example).
	%Lands should also be able to get deleted (2 patches of land with different ID's next to eachother could be merged
	%to one land with 1 ID with a bigger multipolygon).
	
	%If new lands appear in the list, add them to our belief base.
	forall percept(lands(List)), bel(member(land(LandID,OwnerID,MultiPolygon),List), not(land(LandID,_,_)))
		do insert(land(LandID,OwnerID,MultiPolygon)).
		
	%Every cycle deletes old values of the lands and inserts new information about the lands if there are any updates.
	forall percept(lands(List)), bel(land(LandID,OldOwnerID,OldMultiPolygon), member(land(LandID,NewOwnerID,NewMultiPolygon), List))
		do delete(land(LandID,OldOwnerID,OldMultiPolygon)) + insert(land(LandID,NewOwnerID,NewMultiPolygon)).
	
	%Every cycle checks if a piece of land is no longer there)
	forall percept(lands(List)), bel(land(LandID,OwnerID,OldMultiPolygon), not(member(land(LandID,_,_),List)))
		do delete(land(LandID,OwnerID,OldMultiPolygon)).
		
	%Request PERCEPT
	%New requests can be added and already answered requests can be removed from the percept list.
	%We're not sure whether percepts can also be changed, so we're also adding that rule just to be sure.
	
	%If new requests appear in the list, add them to our belief base.
	forall percept(requests(List)), bel(member(request(ID,AnswerList),List), not(request(ID,_)))
			do insert(request(ID,AnswerList)).
	
	%If percepts somehow get updated, delete the old belief and insert an updated one.
	forall percept(requests(List)), bel(request(ID,OldAnswerList), member(request(ID,NewAnswerList), List))
		do delete(request(ID,OldAnswerList)) + insert(request(ID,NewAnswerList)).
	
	%If requests are answered and therefore are no longer in the list, delete the request belief.
	forall percept(requests(List)), bel(request(ID,AnswerList), not(member(request(ID,_),List)))
		do delete(request(ID,AnswerList)).
		
	
	%Percept rules by Wouter Pasman
	%Deletes the old functions list and insert the new one if there is an update of the functions
	if percept(functions(X)), bel(functions(Y)) then delete(functions(Y)) + insert(functions(X)).
	%Deletes the old settings list and insert the new one if there is an update of the settings
	if percept(settings(X)), bel(settings(Y)) then delete(settings(Y)) + insert(settings(X)).
	
	%Account for the indicator concerning green.
	if true then green.
	if true then azc.
}
